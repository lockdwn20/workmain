"""
WorkmAIn Database Models
Database Models v1.1
20251222

SQLAlchemy ORM models for Phase 2.
Models: Note, TimeEntry, Meeting, Project

These map to the PostgreSQL tables created by 001_initial_schema.sql

Version History:
- v1.0: Initial model creation
- v1.1: Fixed created_date to use Computed() for generated column compatibility
"""

from datetime import datetime, date, time
from typing import List, Optional

from sqlalchemy import (
    Column, Integer, String, Text, Boolean, DateTime, Date, Time,
    DECIMAL, ForeignKey, ARRAY, Computed
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import TSVECTOR

Base = declarative_base()


class Project(Base):
    """
    Project model - represents projects under clients.
    
    Each note and time entry can be linked to a project.
    Projects are linked to clients (client model to be added in Phase 6).
    """
    __tablename__ = 'projects'
    
    # Primary key
    id = Column(Integer, primary_key=True)
    
    # Foreign keys
    client_id = Column(Integer, nullable=True)  # References clients.id (Phase 6)
    
    # Fields
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    status = Column(String(50), default='active')
    clockify_project_id = Column(String(255), nullable=True)
    start_date = Column(Date, nullable=True)
    end_date = Column(Date, nullable=True)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.now)
    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now)
    
    # Relationships
    notes = relationship("Note", back_populates="project")
    time_entries = relationship("TimeEntry", back_populates="project")
    
    def __repr__(self):
        return f"<Project(id={self.id}, name='{self.name}', status='{self.status}')>"


class Meeting(Base):
    """
    Meeting model - represents calendar meetings from Outlook.
    
    Notes can be linked to meetings for recurring meeting detection.
    """
    __tablename__ = 'meetings'
    
    # Primary key
    id = Column(Integer, primary_key=True)
    
    # Outlook fields
    outlook_id = Column(String(255), unique=True, nullable=True)
    outlook_recurring_id = Column(String(255), nullable=True)  # For recurring detection
    
    # Fields
    title = Column(String(255), nullable=False)
    start_time = Column(DateTime, nullable=False)
    end_time = Column(DateTime, nullable=False)
    attendees = Column(ARRAY(Text), nullable=True)
    is_recurring = Column(Boolean, default=False)
    notes_captured = Column(Boolean, default=False)
    reminder_sent = Column(Boolean, default=False)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.now)
    
    # Relationships
    notes = relationship("Note", back_populates="meeting")
    
    def __repr__(self):
        return f"<Meeting(id={self.id}, title='{self.title}', start='{self.start_time}')>"


class Note(Base):
    """
    Note model - represents user notes with tags and full-text search.
    
    Notes can be:
    - Standalone (ad-hoc notes)
    - Linked to a meeting (meeting_id)
    - Linked to a project (project_id)
    
    Tags are stored as full names (e.g., ['internal-only', 'carry-forward'])
    and are used for report filtering.
    """
    __tablename__ = 'notes'
    
    # Primary key
    id = Column(Integer, primary_key=True)
    
    # Foreign keys
    project_id = Column(Integer, ForeignKey('projects.id', ondelete='SET NULL'), nullable=True)
    meeting_id = Column(Integer, ForeignKey('meetings.id', ondelete='SET NULL'), nullable=True)
    
    # Fields
    content = Column(Text, nullable=False)
    tags = Column(ARRAY(Text), nullable=False, default=list)  # Full tag names
    source = Column(String(50), nullable=True)  # 'meeting', 'task', 'ad-hoc'
    
    # Full-text search (auto-updated by database trigger)
    searchable = Column(TSVECTOR, nullable=True)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.now)
    created_date = Column(Date, Computed("(created_at::DATE)"), nullable=True)  # Auto-generated by database
    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now)
    
    # Relationships
    project = relationship("Project", back_populates="notes")
    meeting = relationship("Meeting", back_populates="notes")
    
    def __repr__(self):
        tags_str = ', '.join(self.tags) if self.tags else 'no tags'
        content_preview = self.content[:50] + '...' if len(self.content) > 50 else self.content
        return f"<Note(id={self.id}, tags=[{tags_str}], content='{content_preview}')>"
    
    @property
    def display_tags(self) -> str:
        """
        Format tags for display using tag system.
        Returns: "[internal-only] [carry-forward]"
        """
        from workmain.utils.tag_utils import format_tags
        return format_tags(self.tags)
    
    def has_tag(self, tag_full_name: str) -> bool:
        """
        Check if note has a specific tag (full name).
        
        Args:
            tag_full_name: Full tag name (e.g., 'internal-only')
            
        Returns:
            True if note has the tag
        """
        return tag_full_name in (self.tags or [])
    
    def has_any_tag(self, tag_full_names: List[str]) -> bool:
        """
        Check if note has any of the specified tags.
        
        Args:
            tag_full_names: List of full tag names
            
        Returns:
            True if note has at least one of the tags
        """
        return any(tag in (self.tags or []) for tag in tag_full_names)


class TimeEntry(Base):
    """
    Time entry model - represents tracked time with 24-hour format.
    
    Time entries can be:
    - Standalone time tracking
    - Linked to a project
    - Synced with Clockify (clockify_id)
    
    Times are stored in 24-hour format and converted to/from AM/PM for Clockify.
    """
    __tablename__ = 'time_entries'
    
    # Primary key
    id = Column(Integer, primary_key=True)
    
    # Foreign keys
    project_id = Column(Integer, ForeignKey('projects.id', ondelete='SET NULL'), nullable=True)
    
    # Fields
    description = Column(Text, nullable=False)
    duration_hours = Column(DECIMAL(5, 2), nullable=False)  # e.g., 1.50 for 1.5 hours
    category = Column(String(100), nullable=True)  # 'development', 'meeting', 'review', etc.
    tags = Column(ARRAY(Text), nullable=True)
    
    # Clockify integration
    clockify_id = Column(String(255), unique=True, nullable=True)
    synced_at = Column(DateTime, nullable=True)
    
    # Date/time (24-hour format)
    entry_date = Column(Date, nullable=False)
    entry_time = Column(Time, nullable=True)  # 24-hour format: 14:30, 09:00
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.now)
    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now)
    
    # Relationships
    project = relationship("Project", back_populates="time_entries")
    
    def __repr__(self):
        time_str = self.entry_time.strftime('%H:%M') if self.entry_time else 'no time'
        return (f"<TimeEntry(id={self.id}, date={self.entry_date}, time={time_str}, "
                f"duration={self.duration_hours}h, desc='{self.description[:30]}...')>")
    
    @property
    def display_time(self) -> str:
        """
        Format time for display in 24-hour format.
        Returns: "14:30" or "" if no time
        """
        if self.entry_time:
            return self.entry_time.strftime('%H:%M')
        return ""
    
    def is_synced(self) -> bool:
        """Check if time entry has been synced with Clockify."""
        return self.clockify_id is not None and self.synced_at is not None


# Database session management helper
def get_model_by_name(model_name: str):
    """
    Get model class by name.
    
    Args:
        model_name: Name of model ('Note', 'TimeEntry', etc.)
        
    Returns:
        Model class or None if not found
    """
    models = {
        'Note': Note,
        'TimeEntry': TimeEntry,
        'Meeting': Meeting,
        'Project': Project,
    }
    return models.get(model_name)


def get_all_models():
    """
    Get list of all model classes.
    
    Returns:
        List of model classes
    """
    return [Note, TimeEntry, Meeting, Project]